import sys
import json
from typing import TypedDict, Tuple
import enum

ESCAPES = {
	'"': '"',
	'\\': '\\',
}

def take_until_unescaped(needle: str, haystack: str) -> Tuple[str, str] | None:
	assert len(needle) == 1 and needle != '\\'

	ret = ''
	escaped = False
	for i, ch in enumerate(haystack):
		if escaped:
			ret += ESCAPES[ch]
			escaped = False
			continue

		if ch == '\\':
			escaped = True
		elif ch == needle:
			return (ret, haystack[i+1:])
		else:
			ret += ch

	return None

def int_(*args, **kwargs) -> int | None:
	try:
		return int(*args, **kwargs)
	except Exception:
		return None

with open('keysyms.json', 'rb') as f:
	class Record(TypedDict):
		keysym: int
		unicode: int
		status: str
		names: list[str]

	raw: list[Record] = json.load(f)['records']
	KEYSYMS = { name: chr(record['unicode']) for record in raw for name in record['names'] }

class SpecialKeysym(enum.Enum):
	IGNORE_ENTIRE = enum.auto

# These are missing for some reason.
KEYSYMS |= {
	'Oslash': 'Ø',
	'EZH': SpecialKeysym.IGNORE_ENTIRE,
	'ezh': SpecialKeysym.IGNORE_ENTIRE,
	'because': '∵',
}

def lookup_keysym(keysym: str) -> str | SpecialKeysym:
	if len(keysym) == 1:
		return keysym
	elif (entry := KEYSYMS.get(keysym)) is not None:
		return entry
	elif keysym.startswith('dead_'):
		return SpecialKeysym.IGNORE_ENTIRE
	elif keysym.startswith('U') and (unicode := int_(keysym[1:], base=16)) is not None:
		return chr(unicode)
	else:
		raise Exception(f"unknown keysym {repr(keysym)}")

def can_be_easily_typed(ch: str) -> bool:
	return ch.isascii()

# Returns `None` if this should not be considered a Compose sequence.
def parse_keys(raw: str) -> list[str] | None:
	ret: list[str] = []

	raw = raw.strip()
	first = True

	while len(raw) > 0:
		(_, raw) = raw.split('<', 1)
		(this, raw) = raw.split('>', 1)
		this = this.strip()
		raw = raw.lstrip()

		if first:
			if this == "Multi_key":
				first = False
				continue
			else:
				return None

		this = lookup_keysym(this)
		# Compose parts should be easily typeable.
		if isinstance(this, SpecialKeysym) or not can_be_easily_typed(this):
			return None
		ret.append(this)

	return ret

final = {}
for line_number, line in enumerate(sys.stdin, start=1):
	try:
		line = line.strip()

		if len(line) == 0 or line.startswith("#"):
			continue

		(keys, rest) = line.split(':', 1)
		keys = keys.strip()
		rest = rest.strip()

		keys = parse_keys(keys)
		if keys is None:
			continue

		(_, rest) = rest.split('"', 1)
		t = take_until_unescaped('"', rest)
		if t is None:
			raise Exception("something is wrong with the quoted output")
		(output_verbatim, rest) = t
		rest = rest.strip()

		if not rest.startswith('#'):
			(output_keysym, _) = rest.split(None, 1)
			assert output_verbatim == lookup_keysym(output_keysym)

		output = output_verbatim

		# No need to include rules that generate a single character we can already type.
		if len(output) == 1 and can_be_easily_typed(output):
			continue

		final[''.join(keys)] = output
	except Exception as e:
		print(f"error on line {line_number}: {e}", file=sys.stderr)
		sys.exit(1)

EXPLAIN = '// generated by xcompose/xcompose_to_table.py'

print(EXPLAIN)
for (keys, output) in final.items():
	# JSON uses UTF-16, so we get something that works perfectly for Java.
	print(f"table.put({json.dumps(keys)}, {json.dumps(output)});")
print(EXPLAIN)
